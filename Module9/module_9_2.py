# -*- coding: utf-8 -*-

# Домашнее задание по теме "Генераторные сборки"
# Домашнее задание по уроку Генерация функций.
# Цель задания:
# Научиться создавать функции динамически в зависимости от заданных условий и параметров, используя различные подходы,
# такие как фабрики функций, лямбда-функции и вызываемые объекты.
# Теоретический комментарий:
# 1. Динамическое определение функций (def):
# В Python можно определять функции внутри других функций. Такие функции могут создаваться и возвращаться.
# Это основа для создания "фабрик функций" - функций, создающих функции.
#
# 2. Лямбда-функции:
# Лямбда-функции в Python — это анонимные функции, определённые одной строкой. Они удобны для создания простых функций
# на лету, особенно когда функция нужна временно или для одноразового использования.
#
# 3. Вызываемые объекты (__call__):
# В Python у класса может быть метод __call__, что позволяет его экземплярам вести себя как функции.
# Это дает возможность создавать объекты, которые могут быть вызваны как функции и хранить состояние между вызовами.
# Задание:
# Задача 1: Фабрика Функций.
# Написать функцию, которая возвращает различные математические функции (например, деление, умножение)
# в зависимости от переданных аргументов.
#
# Задача 2: Лямбда-Функции
# Использовать лямбда-функцию для реализации простой операции и написать такую же функцию с использованием def.
# Например, возведение числа в квадрат
#
# Задача 3: Вызываемые Объекты.
# Создать класс с Rect c полями a, b, которые задаются в __init__ и методом __call__, который возвращает
# площадь прямоугольника, то есть a*b.

print("Задача 1. Фабрика функций:")


def create_operation(operation):
    if operation == "share":
        def share(x, y):
            if y == 0:
                raise ZeroDivisionError('Error: Division by zero')
            else:
                return x / y

        return share  # возвращаем функцию как объект!! Тут скобки не нужны
    elif operation == "multiply":
        def multiply(x, y):
            return x * y

        return multiply


try:
    my_func_share = create_operation("share")
    print(f'Результат деления: {my_func_share(1, 2)}')
    my_func_multiply = create_operation("multiply")
    print(f'Результат умножения: {my_func_multiply(1, 2)}')
    my_func_share = create_operation("share")
    print(f'Результат деления на ноль: {my_func_share(1, 0)}')
except ZeroDivisionError as exc:
    print(exc)
print()
print("Задача 2. лямбда")
multiply = lambda x: x ** x
print(f'Квадрат числа равен: {multiply(2)}')  # Выводит квадрат переменной Х


def multiply_def(x):  # аналог через def
    return x ** x


print(f'Квадрат числа равен: {multiply_def(2)}')  # Выводит квадрат переменной Х
print()
print("Задача 3. Вызываемые объекты")


class Rect:
    def __init__(self, a, b):
        self.a = a
        self.b = b

    def __call__(self, a, b):
        c = self.a * self.b
        return c


area_rect = Rect(5, 6)
print(f'Площадь прямоугольника равна: {area_rect(1, 1)}')  # Выводит площадь прямоугольника
